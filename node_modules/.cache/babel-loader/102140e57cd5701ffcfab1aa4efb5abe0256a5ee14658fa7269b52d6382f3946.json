{"ast":null,"code":"/**\n * Input validation utilities for the application\n * Provides schema-based validation for all user inputs\n */\n\nimport { UI_CONSTANTS } from '../../config/constants';\n\n// Get ranges from UI constants for validation\nconst {\n  ranges\n} = UI_CONSTANTS;\n\n/**\n * Validation schema for all input fields\n * Each field has validation rules to check against\n */\nexport const inputValidationSchema = {\n  shortEdge: {\n    required: true,\n    type: 'number',\n    min: ranges.shortEdge.min,\n    max: ranges.shortEdge.max,\n    errorMessages: {\n      required: 'Short edge dimension is required',\n      type: 'Short edge must be a number',\n      min: `Short edge must be at least ${ranges.shortEdge.min}mm`,\n      max: `Short edge must be at most ${ranges.shortEdge.max}mm`\n    }\n  },\n  longEdge: {\n    required: true,\n    type: 'number',\n    min: ranges.longEdge.min,\n    max: ranges.longEdge.max,\n    errorMessages: {\n      required: 'Long edge dimension is required',\n      type: 'Long edge must be a number',\n      min: `Long edge must be at least ${ranges.longEdge.min}mm`,\n      max: `Long edge must be at most ${ranges.longEdge.max}mm`\n    }\n  },\n  salesPricePerUnit: {\n    required: true,\n    type: 'number',\n    min: ranges.salesPricePerUnit.min,\n    errorMessages: {\n      required: 'Sales price is required',\n      type: 'Sales price must be a number',\n      min: 'Sales price cannot be negative'\n    }\n  },\n  monthlySalesVolume: {\n    required: true,\n    type: 'number',\n    min: ranges.monthlySalesVolume.min,\n    max: ranges.monthlySalesVolume.max,\n    errorMessages: {\n      required: 'Monthly sales volume is required',\n      type: 'Monthly sales volume must be a number',\n      min: 'Monthly sales volume cannot be negative',\n      max: `Monthly sales volume cannot exceed ${ranges.monthlySalesVolume.max} units`\n    }\n  },\n  materialCostPerUnit: {\n    required: true,\n    type: 'number',\n    min: ranges.materialCostPerUnit.min,\n    errorMessages: {\n      required: 'Material cost is required',\n      type: 'Material cost must be a number',\n      min: 'Material cost cannot be negative'\n    }\n  },\n  laborCostPerHour: {\n    required: true,\n    type: 'number',\n    min: ranges.laborCostPerHour.min,\n    errorMessages: {\n      required: 'Labor cost is required',\n      type: 'Labor cost must be a number',\n      min: 'Labor cost cannot be negative'\n    }\n  },\n  inkPricePerCC: {\n    required: true,\n    type: 'number',\n    min: ranges.inkPricePerCC.min,\n    errorMessages: {\n      required: 'Ink price is required',\n      type: 'Ink price must be a number',\n      min: 'Ink price cannot be negative'\n    }\n  },\n  initialInvestment: {\n    required: true,\n    type: 'number',\n    min: ranges.initialInvestment.min,\n    errorMessages: {\n      required: 'Initial investment is required',\n      type: 'Initial investment must be a number',\n      min: 'Initial investment must be greater than zero'\n    }\n  }\n};\n\n/**\n * Validate a single input value against its schema rules\n * @param {string} name - Field name to validate\n * @param {any} value - Value to validate\n * @param {Object} schema - Validation schema (defaults to inputValidationSchema)\n * @returns {Object} - Validation result {valid: boolean, errors: string[]}\n */\nexport const validateInput = (name, value, schema = inputValidationSchema) => {\n  // Check if field exists in schema\n  const rules = schema[name];\n  if (!rules) {\n    return {\n      valid: true,\n      errors: []\n    };\n  }\n  const errors = [];\n\n  // Required field validation\n  if (rules.required && (value === undefined || value === null || value === '')) {\n    var _rules$errorMessages;\n    errors.push(((_rules$errorMessages = rules.errorMessages) === null || _rules$errorMessages === void 0 ? void 0 : _rules$errorMessages.required) || `${name} is required`);\n  }\n\n  // Skip other validations if value is empty and not required\n  if (value === undefined || value === null || value === '') {\n    return {\n      valid: errors.length === 0,\n      errors\n    };\n  }\n\n  // Type validation\n  if (rules.type === 'number') {\n    const numValue = Number(value);\n    if (isNaN(numValue)) {\n      var _rules$errorMessages2;\n      errors.push(((_rules$errorMessages2 = rules.errorMessages) === null || _rules$errorMessages2 === void 0 ? void 0 : _rules$errorMessages2.type) || `${name} must be a number`);\n    } else {\n      // Minimum value validation\n      if (rules.min !== undefined && numValue < rules.min) {\n        var _rules$errorMessages3;\n        errors.push(((_rules$errorMessages3 = rules.errorMessages) === null || _rules$errorMessages3 === void 0 ? void 0 : _rules$errorMessages3.min) || `${name} must be at least ${rules.min}`);\n      }\n\n      // Maximum value validation\n      if (rules.max !== undefined && numValue > rules.max) {\n        var _rules$errorMessages4;\n        errors.push(((_rules$errorMessages4 = rules.errorMessages) === null || _rules$errorMessages4 === void 0 ? void 0 : _rules$errorMessages4.max) || `${name} must be at most ${rules.max}`);\n      }\n    }\n  }\n\n  // Additional custom validations could be added here\n\n  return {\n    valid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Validate all input fields at once\n * @param {Object} inputs - Object containing all input values\n * @param {Object} schema - Validation schema (defaults to inputValidationSchema) \n * @returns {Object} - Validation results for all fields {fieldName: {valid, errors}}\n */\nexport const validateAllInputs = (inputs, schema = inputValidationSchema) => {\n  const validationResults = {};\n\n  // Validate each field in the schema\n  Object.keys(schema).forEach(fieldName => {\n    validationResults[fieldName] = validateInput(fieldName, inputs[fieldName], schema);\n  });\n  return validationResults;\n};\n\n/**\n * Check if all inputs are valid\n * @param {Object} validationResults - Results from validateAllInputs\n * @returns {boolean} - True if all inputs are valid\n */\nexport const areAllInputsValid = validationResults => {\n  return Object.values(validationResults).every(result => result.valid);\n};","map":{"version":3,"names":["UI_CONSTANTS","ranges","inputValidationSchema","shortEdge","required","type","min","max","errorMessages","longEdge","salesPricePerUnit","monthlySalesVolume","materialCostPerUnit","laborCostPerHour","inkPricePerCC","initialInvestment","validateInput","name","value","schema","rules","valid","errors","undefined","_rules$errorMessages","push","length","numValue","Number","isNaN","_rules$errorMessages2","_rules$errorMessages3","_rules$errorMessages4","validateAllInputs","inputs","validationResults","Object","keys","forEach","fieldName","areAllInputsValid","values","every","result"],"sources":["/Users/nicholasgobert/Desktop/Apps/MOSimulator/src/utils/validation/index.js"],"sourcesContent":["/**\n * Input validation utilities for the application\n * Provides schema-based validation for all user inputs\n */\n\nimport { UI_CONSTANTS } from '../../config/constants';\n\n// Get ranges from UI constants for validation\nconst { ranges } = UI_CONSTANTS;\n\n/**\n * Validation schema for all input fields\n * Each field has validation rules to check against\n */\nexport const inputValidationSchema = {\n  shortEdge: {\n    required: true,\n    type: 'number',\n    min: ranges.shortEdge.min,\n    max: ranges.shortEdge.max,\n    errorMessages: {\n      required: 'Short edge dimension is required',\n      type: 'Short edge must be a number',\n      min: `Short edge must be at least ${ranges.shortEdge.min}mm`,\n      max: `Short edge must be at most ${ranges.shortEdge.max}mm`\n    }\n  },\n  longEdge: {\n    required: true,\n    type: 'number',\n    min: ranges.longEdge.min,\n    max: ranges.longEdge.max,\n    errorMessages: {\n      required: 'Long edge dimension is required',\n      type: 'Long edge must be a number',\n      min: `Long edge must be at least ${ranges.longEdge.min}mm`,\n      max: `Long edge must be at most ${ranges.longEdge.max}mm`\n    }\n  },\n  salesPricePerUnit: {\n    required: true,\n    type: 'number',\n    min: ranges.salesPricePerUnit.min,\n    errorMessages: {\n      required: 'Sales price is required',\n      type: 'Sales price must be a number',\n      min: 'Sales price cannot be negative'\n    }\n  },\n  monthlySalesVolume: {\n    required: true,\n    type: 'number',\n    min: ranges.monthlySalesVolume.min,\n    max: ranges.monthlySalesVolume.max,\n    errorMessages: {\n      required: 'Monthly sales volume is required',\n      type: 'Monthly sales volume must be a number',\n      min: 'Monthly sales volume cannot be negative',\n      max: `Monthly sales volume cannot exceed ${ranges.monthlySalesVolume.max} units`\n    }\n  },\n  materialCostPerUnit: {\n    required: true,\n    type: 'number',\n    min: ranges.materialCostPerUnit.min,\n    errorMessages: {\n      required: 'Material cost is required',\n      type: 'Material cost must be a number',\n      min: 'Material cost cannot be negative'\n    }\n  },\n  laborCostPerHour: {\n    required: true,\n    type: 'number',\n    min: ranges.laborCostPerHour.min,\n    errorMessages: {\n      required: 'Labor cost is required',\n      type: 'Labor cost must be a number',\n      min: 'Labor cost cannot be negative'\n    }\n  },\n  inkPricePerCC: {\n    required: true,\n    type: 'number',\n    min: ranges.inkPricePerCC.min,\n    errorMessages: {\n      required: 'Ink price is required',\n      type: 'Ink price must be a number',\n      min: 'Ink price cannot be negative'\n    }\n  },\n  initialInvestment: {\n    required: true,\n    type: 'number',\n    min: ranges.initialInvestment.min,\n    errorMessages: {\n      required: 'Initial investment is required',\n      type: 'Initial investment must be a number',\n      min: 'Initial investment must be greater than zero'\n    }\n  }\n};\n\n/**\n * Validate a single input value against its schema rules\n * @param {string} name - Field name to validate\n * @param {any} value - Value to validate\n * @param {Object} schema - Validation schema (defaults to inputValidationSchema)\n * @returns {Object} - Validation result {valid: boolean, errors: string[]}\n */\nexport const validateInput = (name, value, schema = inputValidationSchema) => {\n  // Check if field exists in schema\n  const rules = schema[name];\n  if (!rules) {\n    return { valid: true, errors: [] };\n  }\n  \n  const errors = [];\n  \n  // Required field validation\n  if (rules.required && (value === undefined || value === null || value === '')) {\n    errors.push(rules.errorMessages?.required || `${name} is required`);\n  }\n  \n  // Skip other validations if value is empty and not required\n  if (value === undefined || value === null || value === '') {\n    return { valid: errors.length === 0, errors };\n  }\n  \n  // Type validation\n  if (rules.type === 'number') {\n    const numValue = Number(value);\n    if (isNaN(numValue)) {\n      errors.push(rules.errorMessages?.type || `${name} must be a number`);\n    } else {\n      // Minimum value validation\n      if (rules.min !== undefined && numValue < rules.min) {\n        errors.push(rules.errorMessages?.min || `${name} must be at least ${rules.min}`);\n      }\n      \n      // Maximum value validation\n      if (rules.max !== undefined && numValue > rules.max) {\n        errors.push(rules.errorMessages?.max || `${name} must be at most ${rules.max}`);\n      }\n    }\n  }\n  \n  // Additional custom validations could be added here\n  \n  return {\n    valid: errors.length === 0,\n    errors\n  };\n};\n\n/**\n * Validate all input fields at once\n * @param {Object} inputs - Object containing all input values\n * @param {Object} schema - Validation schema (defaults to inputValidationSchema) \n * @returns {Object} - Validation results for all fields {fieldName: {valid, errors}}\n */\nexport const validateAllInputs = (inputs, schema = inputValidationSchema) => {\n  const validationResults = {};\n  \n  // Validate each field in the schema\n  Object.keys(schema).forEach(fieldName => {\n    validationResults[fieldName] = validateInput(fieldName, inputs[fieldName], schema);\n  });\n  \n  return validationResults;\n};\n\n/**\n * Check if all inputs are valid\n * @param {Object} validationResults - Results from validateAllInputs\n * @returns {boolean} - True if all inputs are valid\n */\nexport const areAllInputsValid = (validationResults) => {\n  return Object.values(validationResults).every(result => result.valid);\n};\n"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}